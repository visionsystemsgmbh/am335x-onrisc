add basic BSP

From: Yegor Yefremov <yegorslists@googlemail.com>


---

 arch/arm/mach-omap2/board-am335xevm.c |  145 ++++++++++++++++++++++++++++++++-
 1 files changed, 142 insertions(+), 3 deletions(-)


diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index ab402e4..fbe4e38 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -17,6 +17,8 @@
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/i2c/at24.h>
+#include <linux/i2c/pca953x.h>
+#include <linux/i2c-gpio.h>
 #include <linux/phy.h>
 #include <linux/gpio.h>
 #include <linux/spi/spi.h>
@@ -631,6 +633,7 @@ static struct pinmux_config mmc1_common_pin_mux[] = {
 	{"gpmc_ad0.mmc1_dat0",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
 	{"gpmc_csn1.mmc1_clk",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
 	{"gpmc_csn2.mmc1_cmd",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
+	{"spi0_d0.gpio0_3",    OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
 	{NULL, 0},
 };
 
@@ -659,6 +662,15 @@ static struct pinmux_config uart3_pin_mux[] = {
 	{NULL, 0},
 };
 
+/* Module pin mux for uart5 */
+static struct pinmux_config uart5_pin_mux[] = {
+	{"rmii1_refclk.uart5_txd", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
+	{"mii1_col.uart5_rxd", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT},
+	{"mii1_rxerr.uart5_rtsn", OMAP_MUX_MODE5 | AM33XX_PIN_OUTPUT},
+	{"mii1_crs.uart5_ctsn", OMAP_MUX_MODE5 | AM33XX_PIN_INPUT},
+	{NULL, 0},
+};
+
 static struct pinmux_config d_can_gp_pin_mux[] = {
 	{"uart0_ctsn.d_can1_tx", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
 	{"uart0_rtsn.d_can1_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
@@ -1123,6 +1135,13 @@ static void uart3_init(int evm_id, int profile)
 	return;
 }
 
+/* setup uart5 */
+static void uart5_init(int evm_id, int profile)
+{
+	setup_pin_mux(uart5_pin_mux);
+	return;
+}
+
 /* setup uart2 */
 static void uart2_init(int evm_id, int profile)
 {
@@ -1636,8 +1655,8 @@ static void mmc1_wl12xx_init(int evm_id, int profile)
 {
 	setup_pin_mux(mmc1_common_pin_mux);
 	am335x_mmc[1].mmc = 2;
-	am335x_mmc[1].name = "wl1271";
-	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
+	am335x_mmc[1].name = "libertas";
+	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA /*| MMC_CAP_POWER_OFF_CARD*/;
 	am335x_mmc[1].nonremovable = true;
 	am335x_mmc[1].gpio_cd = -EINVAL;
 	am335x_mmc[1].gpio_wp = -EINVAL;
@@ -1688,6 +1707,45 @@ static int wl12xx_set_power(struct device *dev, int slot, int on, int vdd)
 	return 0;
 }
 
+static void lbs_init(int evm_id, int profile)
+{
+	struct device *dev;
+	struct omap_mmc_platform_data *pdata;
+	int ret;
+
+
+	dev = am335x_mmc[1].dev;
+	if (!dev) {
+		pr_err("lbs mmc device initialization failed\n");
+		goto out;
+	}
+
+	pdata = dev->platform_data;
+	if (!pdata) {
+		pr_err("Platfrom data of lbs device not set\n");
+		goto out;
+	}
+
+	ret = gpio_request(3, "lbs_en\n");
+	if (ret < 0)
+		pr_err("Failed to request gpio for lbs_enable");
+
+	/*ret = gpio_request(4, "lbs_bt_en\n");
+	if (ret < 0)
+		pr_err("Failed to request gpio for lbs_bt_enable");*/
+
+	pr_info("Configure Libertas Enable pin...\n");
+	gpio_direction_output(3, 0);
+	//gpio_direction_output(4, 0);
+	msleep(100);
+	gpio_set_value( 3, 1 );
+	//gpio_set_value( 4, 1 );
+	msleep(100);
+	//pdata->slots[0].set_power = wl12xx_set_power;
+out:
+	return;
+}
+
 static void wl12xx_init(int evm_id, int profile)
 {
 	struct device *dev;
@@ -1756,6 +1814,13 @@ static void d_can_init(int evm_id, int profile)
 	}
 }
 
+static void d_can_init_alekto2(int evm_id, int profile)
+{
+			setup_pin_mux(d_can_gp_pin_mux);
+			/* Instance One */
+			am33xx_d_can_init(1);
+}
+
 static void mmc0_init(int evm_id, int profile)
 {
 	switch (evm_id) {
@@ -2155,6 +2220,23 @@ static struct evm_dev_cfg evm_sk_dev_cfg[] = {
 	{NULL, 0, 0},
 };
 
+/* Alekto2 */
+static struct evm_dev_cfg alekto2_dev_cfg[] = {
+	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{rgmii2_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
+	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc1_wl12xx_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{uart3_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{uart5_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{d_can_init_alekto2,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{lbs_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
+	{lcdc_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{NULL, 0, 0},
+};
+
 static int am33xx_evm_tx_clk_dly_phy_fixup(struct phy_device *phydev)
 {
 	phy_write(phydev, AR8051_PHY_DEBUG_ADDR_REG,
@@ -2253,6 +2335,49 @@ static void setup_starterkit(void)
 				   am33xx_evm_tx_clk_dly_phy_fixup);
 }
 
+static struct i2c_gpio_platform_data pdata = {
+	.sda_pin		= GPIO_TO_PIN(0, 14),
+	.sda_is_open_drain	= 0,
+	.scl_pin		= GPIO_TO_PIN(0, 15),
+	.scl_is_open_drain	= 0,
+	.udelay			= 20,
+};
+
+static struct platform_device hsi2c_gpio_device = {
+	.name			= "i2c-gpio",
+	.id			= 0,
+	.dev.platform_data	= &pdata,
+};
+
+/* Alekto2 */
+static void setup_alekto2(void)
+{
+	int ret;
+
+	pr_info("The board is a Alekto2.\n");
+	//gp_evm_revision = GP_EVM_ACTUALLY_BEAGLEBONE;
+
+	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
+	am335x_mmc[0].gpio_wp = -EINVAL;
+
+	_configure_device(EVM_SK, alekto2_dev_cfg, PROFILE_NONE);
+
+	/* TPS65217 regulator has full constraints */
+	regulator_has_full_constraints();
+
+#if defined(ALEKTO2_I2C_GPIO)
+	i2c_register_board_info(0, alekto2_i2c_boardinfo1, 1);
+	ret = platform_device_register(&hsi2c_gpio_device);
+	if (ret)
+		pr_warning("AM33XX i2c registration failed\n");
+#endif
+
+	/* Fill up global evmid */
+	//am33xx_evmid_fillup(BEAGLE_BONE_A3);
+
+	am33xx_cpsw_init(AM33XX_CPSW_MODE_RGMII,"0:00", "0:01");
+}
+
 static void am335x_setup_daughter_board(struct memory_accessor *m, void *c)
 {
 	int ret;
@@ -2297,6 +2422,7 @@ static void am335x_evm_setup(struct memory_accessor *mem_acc, void *context)
 	am33xx_cpsw_macidfillup(&am335x_mac_addr[0][0],
 				&am335x_mac_addr[1][0]);
 
+#if 0
 	/* get board specific data */
 	ret = mem_acc->read(mem_acc, (char *)&config, 0, sizeof(config));
 	if (ret != sizeof(config)) {
@@ -2344,6 +2470,8 @@ static void am335x_evm_setup(struct memory_accessor *mem_acc, void *context)
 		else
 			goto out;
 	}
+#endif
+	setup_alekto2();
 
 	return;
 
@@ -2430,6 +2558,12 @@ static struct tps65910_board am335x_tps65910_info = {
 	.tps65910_pmic_init_data[TPS65910_REG_VMMC]	= &am335x_dummy,
 };
 
+static struct pca953x_platform_data alekto2_io_cb_info = {
+	.gpio_base	= OMAP_MAX_GPIO_LINES,
+};
+static struct pca953x_platform_data alekto2_io_pb_info = {
+	.gpio_base	= OMAP_MAX_GPIO_LINES + 16,
+};
 /*
 * Daughter board Detection.
 * Every board has a ID memory (EEPROM) on board. We probe these devices at
@@ -2461,7 +2595,12 @@ static struct i2c_board_info __initdata am335x_i2c0_boardinfo[] = {
 		.platform_data  = &am335x_tps65910_info,
 	},
 	{
-		I2C_BOARD_INFO("tlv320aic3x", 0x1b),
+		I2C_BOARD_INFO("tca6416", 0x20),
+		.platform_data = &alekto2_io_cb_info,
+	},
+	{
+		I2C_BOARD_INFO("tca6416", 0x21),
+		.platform_data = &alekto2_io_pb_info,
 	},
 };
 
